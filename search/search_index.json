{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Airy Alicanto","text":"<p>An Alicanto is a bird from  Chilean mythology known to eat gold or silver and then glow. The bird is incapable of flight after overindulging on ore.</p> <p>Airy Alicanto represents the origin of CogniPilot's light weight, and minimalistic software stack following a correct by construction software paradigm.</p>"},{"location":"#correct-by-construction-design-drivers","title":"Correct by Construction Design Drivers","text":"<p>CogniPilot is not aiming to re-invent an opensource autopilot that can be a drop in replacement for use in Hobby drones, FPV Racing drones, or a wide variety of DIY autonomous vehicles, there are many great autopilots for that (ArduPilot, BetaFlight, PX4). CogniPilot instead focuses on state-of-the-art methologies for creating an autopilot with mathematically provable robustness properties. In order to achieve this level of reliability, accurate mathematical models of the vehicle and control software must be established that are beyond the expected domain of many hobbyists. However, for those willing to pursue the extra steps to create a mathematical model of their vehicle, templates are available to enable out of tree custom vehicles. CogniPilot is a new class of open source autopilot that can conduct safety critical missions such as transporting people, with a level of safety assurance not currently available in other open source autopilots.</p> <ul> <li> <p>Minimum Viable Code for the Mission: By minimizing the lines of source code and branching, CogniPilot ensures higher reliability, maintainability, and verifiability of the project. </p> </li> <li> <p>Minimize Branch Statements in Control and Estimation Code: CogniPilot generally classifies its code components into two areas. The first is low-level driver and application code. The second is guidance, control, and estimation code for the vehicle. Developers carefully consider the addition of each branch (if statement etc.) in the code for the estimator and controller, as developers are modelling the entire system mathematically. Each branch statement considerably complicates the verification task.</p> </li> <li> <p>Minimize Maintenance to Maintain Reliability: A goal of CogniPilot is to support a wide variety of vehicles (Planes, Copters, Boats, Rovers, Submersibles) and user applications while maintaining software integrity and reliaiblity. CogniPilot plans to limit official support for each release to a minimal amount of vehicles for each class, while providing out of tree support via templates.</p> </li> <li> <p>Deprecate if No-longer Maintained: On each release cycle, the CogniPilot technical steering committee (TSC) will make a decision on whether to maintain official support for each vehicle platform or whether to adopt a new platform. This is to combat the slow creep in lines of code due to vehicle specific edge cases. </p> </li> </ul>"},{"location":"#software-stack","title":"Software Stack","text":"<ul> <li>Ubuntu 22.04</li> <li>Zephyr RTOS 3.5</li> <li>ROS 2 Humble</li> <li>Gazebo Garden</li> </ul>"},{"location":"#currently-supported-platforms","title":"Currently supported platforms","text":""},{"location":"#rover","title":"Rover","text":"<ul> <li>B3RB</li> <li>ELM4</li> </ul>"},{"location":"#get-started","title":"Get started","text":"<p>To get started follow the guide on how to install on a computer.</p>"},{"location":"#cognipilots-next-release","title":"CogniPilot's next release","text":"<p>To still be named, but going by B-Mythical (a mythical creature with a name starting with B) will have planned additional support for:</p>"},{"location":"#mulirotor","title":"Mulirotor","text":"<ul> <li>NXP RDDrone</li> <li>TBD</li> </ul>"},{"location":"#submersible","title":"Submersible","text":"<ul> <li>TBD</li> </ul>"},{"location":"#plane","title":"Plane","text":"<ul> <li>TBD</li> </ul>"},{"location":"cerebri/about/","title":"About Cerebri","text":"<p>Cerebri is a correct by construction autopilot. This software paradigm simplifies the verifcation and validation task through the consideration of ease of verification during code creation.</p> <p>The verification approach relies on the faithful synthesis of mathematical control laws for a given vehicle dynamic model interacting with a finite state machine. A layered approach is used to ensure robustness of the sytem.</p>"},{"location":"cerebri/about/#layers-of-verificaiton-and-validation","title":"Layers of Verificaiton and Validation","text":"<ul> <li>MISRA C compliance. Follow closely the industry best practices as defined in the MISRA C standard. The verification of the high levels of system operation use the low level operating system and drivers as a foundation.</li> <li>On top of the the solid operating system and drivers, create control and estimation methods that interact with a given dynamic model. For interested readers, see this paper of one such robust control strategy.</li> </ul>"},{"location":"cerebri/about/#zros-publish-and-subscribe-library","title":"ZROS Publish and Subscribe Library","text":"<p>After considering both the rclc library and ZBUS, it was determined to be advantageous to construct a tailored publish/subscribe library for use in Cerebri.</p>"},{"location":"cerebri/about/#comparison-to-other-libraries","title":"Comparison to Other Libraries","text":"Library Thread-safe Misra C Community Base Separate Read/Write Locks Lines of Code rclc no no large N/A ~29k ZBUS yes yes small no 1409 ZROS yes yes new library yes 748 <p>While Cerebri was initially built around ZBUS, it was found too limiting due to the available topic listener and subscriber implementations. Instead of providing callback functions where the topic data structure is in context, ZROS signals the subscribers that a new message is availabe. It is then up to the subscriber to process the data. This is similar to a ZBUS subscriber, but it uses signals instead of message queues. In ZROS, it is imperative that the latest sensor data is available to each node, but skipping packets between nodes is acceptable. All messages describing the state of the vehicle are stateful, so dropping one message is not critical. This is also the goal for all input to the system. It should be assuemd that packets will be lost, and the requests of the user should be a state that is continually sent at a periodic rate.</p> <p>Cerebri is constructed using a set of reusable nodes. These nodes communicate using topics. ZROS is thread-safe and leverages a read semaphore and a write mutex lock on each topic. This allows multiple subscribers to read the data simultaneously.</p>"},{"location":"cerebri/about/#general-structure","title":"General Structure","text":"<p>In order to simplify the verification process, the vehicle management firmware is divided into various subcomponents.</p> <ul> <li>Operating Systeam: Cerebri leverages the Zephyr RTOS, which is working towards MISRA C compliance.</li> <li>drivers: The drivers are low level operating system code to talk with various sensors, actuators etc. Drivers are primarily maintained in upstream Zephyr.</li> <li>lib: The libraries in Cerebri are divided into application specific folders. The libraries are typically reusable modules that may be incorporated into an application. They interface the low level drivers with the ZROS library.<ul> <li>actuate: Deals with actuating motors, servos, sound, lights etc.</li> <li>core: Common application code and system workqueues.</li> <li>dream: Simulation specific modules.</li> <li>sense: Interfaces sensor drivers with the ZROS module</li> <li>synapse: Communicaiton based modules</li> </ul> </li> <li>app: The application folder is where the vehicle finite state machine, control, and estimation code reside. By tailoring these components to a specific vehicle and use case it makes it more flexible for users to adapt and it also makes the verification tasks simpler as there is less code dealing with generalizations and abstractions to allow reuse on multiple vehicles.</li> </ul> <p>This structure allows for focus on the applications specific code for verification and validation. The state machine of the B3RB for example is written so that it can be easily adapted for model checking. The algorithms in <code>Cyecca</code> can also be analyzed with a dynamic model of the system to provide the mechanisms for hybrid model checking.</p>"},{"location":"cerebri/boards/nxp_mr_canhubk3/","title":"NXP MR CANHUBK3","text":"<p>More documentation coming soon.</p> <p>NXP documentation</p>"},{"location":"cerebri/boards/nxp_vmu_rt1170/","title":"NXP VMU RT1170 Overview","text":"<p>More documentation coming soon.</p> <p>Board schematics</p>"},{"location":"cerebri/platforms/rovers/","title":"Rovers Overview","text":""},{"location":"cranium/about/","title":"About Cranium","text":"<p>Cranium holds all of the higher level computation for CogniPilot. It is a ROS workspace.</p>"},{"location":"cranium/compute/navqplus/setup/","title":"NavQPlus set up for CogniPilot with ROS 2 Humble","text":"Looking for instructions on how to also install on a development computer? <p>Click here to get instructions on how to setup and configure a development computer.</p> Already previously followed all the steps to flash and configure the image on the NavQPlus and want to jump to installing CogniPilot on it? <p>Click here to jump to installing CogniPilot on NavQPlus.</p> About this guide <p>These directions are written for someone with experience with embedded Linux and basic embedded computers.</p>"},{"location":"cranium/compute/navqplus/setup/#step-by-step-overview","title":"Step-by-step overview","text":"<ol> <li>Download the pre-built latest image with Ubuntu<sup>1</sup> 22.04 and ROS 2<sup>3</sup> Humble, exact instructions for that release image are included on the release documentation to use in conjunction with this guide.</li> <li>Extract the image <code>navqplus-image-&lt;version&gt;.wic</code> from the compressed downloaded file <code>navqplus-image-&lt;version&gt;.wic.zstd</code> and flash it to the EMMC, exact copy and paste instructions are on the release page.</li> <li>Log in for the first time by connecting to another computer using the USB to UART adatper, ethernet adapter or centermost (USB 2) USB-C\u00ae port.<sup>2</sup></li> <li>Configure WiFi, System User Name and Password.</li> <li>Connect to NavQPlus over WiFi</li> <li>Install CogniPilot by running the included installer script.</li> </ol>"},{"location":"cranium/compute/navqplus/setup/#flashing-the-emmc","title":"Flashing the eMMC","text":"<p>To flash the eMMC on the NavQPlus use the uuu tool as part of the downloadable assests from the release.</p> <p>Once <code>uuu</code> has downloaded make sure to set it as executable.</p> Make uuu executable:<pre><code>chmod a+x uuu\n</code></pre> <p>find the boot switches on the NavQPlus and flip them to the \"Flash\" mode.</p> <p>Then, connect NavQPlus to the computer with the downloaded release using the leftmost (USB 1) USB-C\u00ae port and the two flash status lights should light up. </p> Flash eMMC hookup and status lights. <p></p> <p>Make sure that the NavQPlus is recognized by <code>uuu</code>.</p> Check if uuu sees NavQPlus:<pre><code>./uuu -lsusb\n</code></pre> Found device with uuu. <p></p> <p>If it shows that a device is connected, continue to flashing. To flash the board, use the general command below or copy and paste the specific command from the release.</p> Use uuu to flash eMMC with image:<pre><code>sudo ./uuu -b emmc_all navqplus-image-&lt;version&gt;.bin-flash_evk navqplus-image-&lt;version&gt;.wic\n</code></pre> <p>Once this process has finished, make sure that the flash was successfull. If so, configure the boot switches to boot from eMMC.</p> Successful eMMC flash. <p></p> uuu gave a weird output abort message after flashing, did it work correctly? <p>There is a know issue where uuu will throw an assertion failed error as seen below, however, the image is flashed correctly and the remaining steps setup and install steps can be followed. </p>"},{"location":"cranium/compute/navqplus/setup/#boot-switches","title":"Boot Switches","text":"<p>NavQPlus can be configured to boot from either SD card or eMMC. It also has a flash mode that allows for to flashing either the eMMC or SD card over USB-C\u00ae. See the table below for the boot switch configuration. Note we suggest to only flash and run from eMMC and leave the SD card for external storage.</p> Mode Switch 1 Switch 2 SD ON ON eMMC OFF ON Flash ON OFF"},{"location":"cranium/compute/navqplus/setup/#log-in-for-the-first-time","title":"Log in for the first time","text":"<p>Power on the NavQPlus by plugging in a USB-C\u00ae cable to the centermost (USB 2) USB-C\u00ae port or the 5 pin JST-GH power port if not powering over the centermost (USB 2) USB-C\u00ae port. NavQPlus will boot, and dispaly that it is fully booted with the status LEDs on board. The 3 LEDs by the USB1 port should be on, as well as two LEDs next to the CAN bus connectors.</p> <p>To log into NavQPlus, choose between using the included USB to UART adapter, Industrial Ethernet, or USB-C\u00ae with gadget ethernet mode. The default username/password combo is as follows:</p> <p>Username: user</p> <p>Password: user</p>"},{"location":"cranium/compute/navqplus/setup/#usb-to-uart-adapter","title":"USB to UART adapter","text":"<p>Connect the included USB to UART adapter to the UART2 port on the NavQPlus, and open a serial console application with a baud rate of 115200 8N1. Press enter if there is no output on the screen to get a log-in prompt.</p> Use screen to connect over USB to UART:<pre><code>screen /dev/ttyUSB&lt;#&gt; 115200\n</code></pre> How to close cleanly out of <code>screen</code>. <p>To exit <code>screen</code> cleanly when done press simultaneously <code>Ctrl Shift A</code> followed by typing <code>k</code> then <code>y</code>.</p>"},{"location":"cranium/compute/navqplus/setup/#ethernet","title":"Ethernet","text":"<p>Connect the included IX Industrial Ethernet cable to NavQPlus, and connect the RJ45 connector to another computer, switch, or router on the local network. Log into NavQPlus over SSH.</p> Connect to NavQPlus over ssh:<pre><code>ssh &lt;username&gt;@&lt;hostname&gt;.local\n</code></pre> Another way to connect to NavQPlus over ssh depending on network setup:<pre><code>ssh &lt;username&gt;@&lt;hostname&gt;\n</code></pre> Changing hostname <p>Default hostname is <code>imx8mpnavq</code>. The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network.</p>"},{"location":"cranium/compute/navqplus/setup/#usb-c-gadget-ethernet","title":"USB-C\u00ae Gadget Ethernet","text":"<p>The IP address of the <code>usb0</code> network interface on NavQPlus is statically assigned to 192.168.186.3. To use the USB-C\u00ae gadget ethernet to connect to the NavQPlus, assign a static IP on the connecting computers existing gadget ethernet interface. The network configuration is as follows:</p> <p>IP Address: 192.168.186.2</p> <p>Network Mask: 255.255.255.0</p> Adding the network configuration to Network Manager. <p></p> <p>Once USB-C\u00ae gadget ethernet interface is set up on the connected computer, connect over SSH.</p> Connect to NavQPlus over ssh:<pre><code>ssh &lt;username&gt;@&lt;hostname&gt;.local\n</code></pre> Another way to connect to NavQPlus over ssh depending on network setup:<pre><code>ssh &lt;username&gt;@&lt;hostname&gt;\n</code></pre> Changing hostname <p>Default hostname is <code>imx8mpnavq</code>. The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network.</p>"},{"location":"cranium/compute/navqplus/setup/#configuring-wifi-system-hostname-username-or-password","title":"Configuring WiFi, System Hostname, Username or Password","text":""},{"location":"cranium/compute/navqplus/setup/#configuring-wifi-on-navqplus","title":"Configuring WiFi on NavQPlus","text":"<p>To connect NavQPlus to a WiFi network, use the <code>nmcli</code> command. The interface is relatively straightforward, to connect with <code>nmcli</code>.</p> Connect NavQPlus to WiFi using nmcli:<pre><code>sudo nmcli device wifi connect &lt;network_name&gt; password \"&lt;password&gt;\"\n</code></pre> <p>If struggling to connect to a network, see if the network is visible.</p> Check WiFi networks visible to the NavQPlus:<pre><code>sudo nmcli device wifi list\n</code></pre> <p>Once connected to the WiFi network the NavQPlus will continue to connect to that network even after a reboot.</p> What WiFi network is the NavQPlus currently connected to? <p>To see what WiFi network the NavQPlus is currently connected to run previous command without <code>sudo</code>.</p> Check current WiFi network NavQPlus is connected to:<pre><code>nmcli device wifi list\n</code></pre> <p>Or if running with <code>sudo</code> it will be the network preceeded with a star.</p>"},{"location":"cranium/compute/navqplus/setup/#optional-configuring-system-hostname-username-or-password","title":"OPTIONAL - Configuring System Hostname, Username or Password","text":"<p>Optionally, to change the default hostname, username, or password, see below.</p>"},{"location":"cranium/compute/navqplus/setup/#change-hostname","title":"Change Hostname","text":"Change the hostname:<pre><code>hostnamectl set-hostname &lt;new_hostname&gt;\n</code></pre>"},{"location":"cranium/compute/navqplus/setup/#change-username","title":"Change Username","text":"<p>Danger</p> <p>Changing the <code>username</code> can be dangerous and possibly result in a broken system state requiring a re-flash.</p> Change the username:<pre><code>usermod -l &lt;new_username&gt; user\nmv /home/user /home/&lt;new_username&gt;\n</code></pre>"},{"location":"cranium/compute/navqplus/setup/#change-password","title":"Change Password","text":"Change the password:<pre><code>passwd\n</code></pre>"},{"location":"cranium/compute/navqplus/setup/#connecting-to-navqplus-over-wifi","title":"Connecting to NavQPlus over WiFi","text":"<p>Once setup to connect over a local WiFi network, SSH into the NavQPlus.</p> Connect to NavQPlus over ssh:<pre><code>ssh &lt;username&gt;@&lt;hostname&gt;.local\n</code></pre> Another way to connect to NavQPlus over ssh depending on network setup:<pre><code>ssh &lt;username&gt;@&lt;hostname&gt;\n</code></pre> Changing hostname <p>Default hostname is <code>imx8mpnavq</code>. The hostname can be changed and is suggested to be changed if running multiple NavQPlus on the same network.</p>"},{"location":"cranium/compute/navqplus/setup/#install-cognipilot-through-included-script","title":"Install CogniPilot through included script","text":"<p>Included in the image is an installation script that auto-updates when run. Before running make sure that the NavQPlus is connected to the internet on a network that allows it to download from github and Ubuntu servers.</p> <p>In the home directory there is a simple helper script that downloads and runs the latest CogniPilot NavQPlus installer.</p> Cloning with ssh keys: <p>If you want to use SSH keys with github on the NavQPlus you must first add or create them on the device. Otherwise you will need to answer <code>n</code> when asked to clone using already setup github ssh keys.</p> Install CogniPilot on NavQPlus:<pre><code>./install_cognipilot.sh\n</code></pre> When prompted to choose whether or not to use ssh-keys: <ul> <li>y to clone with ssh keys, best for development work but only select if ssh keys are already present and setup with GitHub.</li> <li>n to clone with https, best for users who do not plan to make modifications or develop.</li> </ul> When prompted to choose whether or not to optimize runtime performance: <p>It is reccomended to select <code>y</code> for runtime optimization when prompted.</p> When prompted to choose a release: <ol> <li>airy for a stable non-development release.</li> <li>main for active development.</li> </ol> When prompted to choose a platform to build: <ol> <li>b3rb is an ackermann based mobile robotic platform.</li> <li>elm4 is a differential drive based mobile robotic platform.</li> </ol> Does CycloneDDS need configuring? <p>The NavQPlus Ubuntu 22.04 with ROS 2 Humble image uses CycloneDDS by default. Make sure to edit the default CycloneDDSConfig.xml to only allow the networks that are desired to connector over when trying to get maximal performance. An example of this is using only the WiFi device <code>mlan0</code> to connect to a ROS 2 Domain. To save performance remove the other default included interfaces <code>eth1</code> and <code>usb0</code> by deleting those lines from the NavQPlus local <code>~/CycloneDDSconfig.xml</code>.</p> <ol> <li> <p>Ubuntu is a registered trademark of Canonical Ltd.\u00a0\u21a9</p> </li> <li> <p>USB-C\u00ae is a trademark of USB Implementers Forum.\u00a0\u21a9</p> </li> <li> <p>ROS 2 is governed by Open Robotics.\u00a0\u21a9</p> </li> </ol>"},{"location":"cranium/corti/corti/","title":"Corti Overview","text":"<p>Corti is the center fo machine learningk, path planning, dynamic mission adapation, and other advanced tasks.</p> <p>For the Airy release, Corti supports a bezier spline based trajectory generation for a rover. The generated trajectory and control inputs can be used to generate smooth paths for path planning.</p> <p>Corti also has additional functionality based nodes such as one that transforms odometry messages into tf messages for ROS.</p>"},{"location":"cranium/synapse/synapse/","title":"Synapse Overview","text":"<p>Synapse is the general communication layer of CogniPilot. The goal of synapse is to provide an easily usable pub/sub mechanism which is efficient and easily extendible by users.</p>"},{"location":"cranium/synapse/synapse/#synapse-protobuf","title":"Synapse Protobuf","text":"<ul> <li>Synapse Protobuf defines the messages for CogniPilot in the Protobuf language. These messages are ROS compliant and NanoPB compliant.</li> <li>Protobuf provides both a message definition format and a serialization format. One advantage of the protobuf serialization compared to CDR serialiation embedded in ROS is that the message fields are optional and can be enabled with binary flags. In addition NanoPB is a much smaller code base than existing CDR libraries and the NanoPB library is more stable and has more Zephyr RTOS support.</li> <li>CDR serialization support is being considered in B-Mythical to simplify ROS integration.</li> </ul>"},{"location":"cranium/synapse/synapse/#synapse-tinyframe","title":"Synapse TinyFrame","text":"<ul> <li>Synapse TinyFrame is a TinyFrame based library for creating data frames to be sent over serial interfaces such as UART, telenet, and sockets. Checksums and mutex are configurable using the TF_Config.h.</li> <li>Synapse TinyFrame allows for a simple point to point protocol using the known topic key values pairs defined in SynapseTopic.h. This is in contrast to protocols such as zenoh where key value pairs are negotiated. This saves the overhead of the negotiation phase, but if more advanced communication topologies are needed, a synapse_zenoh is planned in the next release.</li> </ul>"},{"location":"cranium/synapse/synapse/#synapse-ros","title":"Synapse ROS","text":"<ul> <li>Synpase ROS is a bridge between the ROS pub/sub system and the Synapse TinyFrame + Synapse Protobuf based link to Cerebri. This allows communication between the more advanced algorithms in Cranium with the low level estimation and control algorithms running within Cerebri.</li> </ul>"},{"location":"cranium/synapse/synapse/#synapse-gz","title":"Synapse GZ","text":"<ul> <li>Synpase GZ is a bridge between the gazebo pub/sub system and the Synapse TinyFrame + Synapse Protobuf based link to Cerebri. This allows direct communication between the Gazebo simulator and Cerebri which is more effiecient for Software In the Loop (SIL) simulation.</li> </ul>"},{"location":"cranium/synapse/synapse/#synapse-msgs","title":"Synapse Msgs","text":"<ul> <li>Synapse Msgs contains standard ROS messages that were created to more easily interface with CogniPilot systems such as Cerebri.</li> </ul>"},{"location":"cranium/synapse/synapse/#example-adding-a-new-message","title":"Example: Adding a New Message","text":"<p>Create a new file: ~/cognipilot/cranium/src/synapse_protobuf/proto/my_msg.proto</p> <p>For more information on .proto and NanoPB options files see NanoPB.</p> <pre><code>syntax = \"proto3\";\npackage synapse.msgs;\n\nimport \"header.proto\";\nimport \"vector3.proto\";\nimport \"quaternion.proto\";\n\nmessage MyMsg {\n  Header header = 1;\n  Quaternion my_quaternion = 2;\n  repeated double my_array_of_doubles = 3;\n}\n</code></pre> <p>Create a new nanopb options file: ~/cognipilot/cranium/src/synapse_protobuf/proto/my_msg.options <pre><code>synapse.msgs.MyMsg.my_array_of_doubles max_count:9\n</code></pre></p> <p>Add topic for your message in ~/cognipilot/cranium/src/synapse_tinyframe/include/synapse_tinyframe/Synapse Topic.h</p> <ul> <li>Consider adding to synapse_ros and synapse_\\gz message handling if required.</li> <li>Rebuild cranium. <pre><code>cd ~/cognipilot/cranium\ncolcon build --symlink-install\n</code></pre></li> <li>Push synapse_protobuf and synapse_tinyframe to your git repository.</li> <li>Update west in Cerebri to point to your git repository: west.yml</li> <li>Add to Cerebri ZROS topic.</li> <li>Add ROS to Cerebri Listener if necessary see code.  <pre><code>#define TOPIC_LISTENER(CHANNEL, CLASS)                                        \\\nstatic TF_Result CHANNEL##_listener(TinyFrame* tf, TF_Msg* frame)             \\\n{                                                                             \\\n    CLASS msg = CLASS##_init_default;                                         \\\n    pb_istream_t stream = pb_istream_from_buffer(frame-&gt;data, frame-&gt;len);    \\\n    int rc = pb_decode(&amp;stream, CLASS##_fields, &amp;msg);                        \\\n    if (rc) {                                                                 \\\n        zros_topic_publish(&amp;topic_##CHANNEL, &amp;msg);                           \\\n        LOG_DBG(\"%s decoding\\n\", #CHANNEL);                                   \\\n    } else {                                                                  \\\n        LOG_WRN(\"%s decoding failed: %s\\n\", #CHANNEL, PB_GET_ERROR(&amp;stream)); \\\n    }                                                                         \\\n    return TF_STAY;                                                           \\\n}\n\n...\n\nTOPIC_LISTENER(bezier_trajectory, synapse_msgs_BezierTrajectory)\n\n...\n\nTF_AddTypeListener(&amp;ctx-&gt;tf, SYNAPSE_BEZIER_TRAJECTORY_TOPIC, bezier_trajectory_listener);\n</code></pre></li> </ul> <p>The following code runs in a loop to process the received bytes and use TinyFrame to process data frames. See TinyFrame for further documentation.</p> <pre><code>int len = zsock_recv(ctx-&gt;client, ctx-&gt;rx1_buf, sizeof(ctx-&gt;rx1_buf), 0);\nTF_Accept(&amp;ctx-&gt;tf, ctx-&gt;rx1_buf, len);\n</code></pre> <ul> <li>Add Cerebri to ROS Publisher if necessary see code</li> </ul> <p>The publisher uses TF\\Send to frame the message so that it can be sent via serial or ethernet etc.</p> <pre><code>#define TOPIC_PUBLISHER(DATA, CLASS, TOPIC)                               \\\n{                                                                         \\\n    TF_Msg msg;                                                           \\\n    TF_ClearMsg(&amp;msg);                                                    \\\n    uint8_t buf[CLASS##_size];                                            \\\n    pb_ostream_t stream = pb_ostream_from_buffer((pu8)buf, sizeof(buf));  \\\n    int rc = pb_encode(&amp;stream, CLASS##_fields, DATA);                    \\\n    if (rc) {                                                             \\\n        msg.type = TOPIC;                                                 \\\n        msg.data = buf;                                                   \\\n        msg.len = stream.bytes_written;                                   \\\n        TF_Send(&amp;ctx-&gt;tf, &amp;msg);                                          \\\n    } else {                                                              \\\n        printf(\"%s encoding failed: %s\\n\", #DATA, PB_GET_ERROR(&amp;stream)); \\\n    }                                                                     \\\n}\n</code></pre> <p>This code checks if there is an update on the ZROS status topic, if there is, it publishes a status message using TF as defined above.</p> <pre><code>if (zros_sub_update_available(&amp;ctx-&gt;sub_status)) {\n   zros_sub_update(&amp;ctx-&gt;sub_status);\n   TOPIC_PUBLISHER(&amp;ctx-&gt;status, synapse_msgs_Status, SYNAPSE_STATUS_TOPIC);\n}\n</code></pre>"},{"location":"dream/worlds/worlds/","title":"Dream Worlds Overview","text":"<p>Run the desired simulated world in gazebo garden by appending <code>world:=&lt;desired-world-name&gt;</code> to the simulation launch script.</p>"},{"location":"dream/worlds/worlds/#depot-world","title":"Depot World","text":"<p>To use depot world append <code>world:=depot</code> to the simulation launch script.</p> Depot world is a highly graphics intensive world that simulates a small warehouse. <p></p>"},{"location":"dream/worlds/worlds/#basic-map-world","title":"Basic Map World","text":"<p>To use basic map world append <code>world:=basic_map</code> to the simulation launch script.</p> Basic map world is very minimalistic to help users on less capable machines. <p></p> How do I add a different world? <ul> <li>It is very easy to add other worlds to dream for use in simulation, there are only a few things to keep in mind:<ol> <li>Make sure the desired model assets work correctly in Gazebo Garden (this includes checking the SDF version)</li> <li>Add the worlds model assets to <code>dream_world/models/&lt;model name&gt;</code></li> <li>Create a unique named world sdf file in <code>dream_world/worlds/</code></li> <li>Make sure the world name stays as <code>default</code> so the sensors can be properly mapped through the ros_gz bridge.</li> <li>Add all the sensor plugins and required world defaults.</li> <li>Include the desired model.</li> <li>Append the worlds unique file name (without .sdf) to the simulation launch script.</li> </ol> </li> </ul>"},{"location":"electrode/about/","title":"About Electrode","text":"<p>Much like the name implies from the medical term, Electrode is the introspection and user interface to CogniPilot's Cranium and Cerebri.</p> <p>Electrode is primarily a ROS 2 workspace that allows for controlling robotic platforms through either foxglove or RVIZ 2 backends.</p> <p>Electrode uses a joystick whether (virtual or physical) to control platforms.</p> <p>Foxglove-studio is the reccomended backend for Electrode.</p> Do I have to use a ROS 2 workspace based Electrode to control platforms? <p>No, there is a way to use Electrode with foxglove and the CogniPilot extensions on windows and linux that only uses websockets and does not require ROS 2 to be present on the system.</p>"},{"location":"electrode/about/#foxglove-studio-backend-for-electrode","title":"Foxglove-studio backend for Electrode.","text":"<p>By default Electrode uses foxglove-studio as the backend, for foxglove-studio to connect to a physical platform or simulation <code>foxglove_bridge</code> must be running first on the target system.</p>"},{"location":"electrode/about/#install-foxglove-studio-and-the-foxglove-cognipilot-joystick-extension","title":"Install foxglove-studio and the foxglove CogniPilot Joystick extension","text":"<p>Run the <code>build_foxglove</code> script after following initial develpment system setup and follow the prompts.</p> Run build_foxglove script:<pre><code>build_foxglove\n</code></pre> <p>Proceed to using Electrode with foxglove-studio with the platforms specific layout:</p> <ul> <li>B3RB </li> <li>B3RB Simulation</li> </ul>"},{"location":"electrode/about/#rviz-2-backend-for-electrode","title":"RVIZ 2 backend for Electrode","text":"<p>Electrode can be optionally run with the RVIZ 2 backend, however, it requires a physical joystick device for input. Electrode with RVIZ 2:<pre><code>ros2 launch electrode electrode.launch.py rviz2:=true\n</code></pre> By defualt RVIZ 2 uses B3RB as the vehicle platform but can be changed with <code>vehicle:=&lt;platform-name&gt;</code></p> <ul> <li>B3RB </li> <li>B3RB Simulation</li> </ul>"},{"location":"electrode/about/#joy-input","title":"Joy Input","text":"<p>Any compatible <code>Joy</code> input can be used to control the platform.</p>"},{"location":"electrode/about/#joy-input-message-example-for-b3rb","title":"Joy input message example for B3RB","text":"<p>The <code>sensor_msgs/Joy</code> message on topic <code>/cerebri/in/joy</code> controls the <code>b3rb</code>, inspect the message to see the field mappings. ros2 topic echo /cerebri/in/joy<pre><code>---\nheader:\n  stamp:\n    sec: 0\n    nanosec: 0\n  frame_id: ''\naxes:\n- 0.0\n- 0.0      #(1)\n- 0.0\n- 0.0      #(2)\nbuttons:\n- 0        #(3)\n- 0        #(4)\n- 0        #(5)\n- 0        #(6)\n- 0        #(7)\n- 0        #(8)\n- 0        #(9)\n- 0        #(10)\n---\n</code></pre></p> <ol> <li>Throttle in  Manual Mode .</li> <li>Steering in  Manual Mode .</li> <li> Manual Mode </li> <li> Auto Mode </li> <li> CMD_VEL Mode </li> <li> Calibration Mode </li> <li>Front Lights On</li> <li>Front Lights Off</li> <li>Disarm</li> <li>Arm</li> </ol>"},{"location":"electrode/about/#foxglove-cognipilot-joystick-extension","title":"Foxglove CogniPilot Joystick extension","text":"Install foxglove-studio and build the foxglove CogniPilot Joystick extension <p>Make sure to have first run the <code>build_foxglove</code> script at some point and follow the prompts. Run build_foxglove script:<pre><code>build_foxglove\n</code></pre></p> <p>The foxglove CogniPilot Joystick extension allows users to control a platform without the need for a physical joystick.</p> Using the CogniPilot Joystick extension in foxglove. <p>Use is simple, click the corresponding buttons to perform their actions. An example on B3RB, click and drag the smaller circle around for throttle (up/down) and steering (left/right).</p> <p></p> Can I still use a physical josytick with foxglove? <p>A physical Joystick can still be used with foxglove but it requires closing the <code>CogniPilot Joystick</code> panel that is automatically opened when importing a layout file like the <code>b3rb.json</code> layout and running electrode with <code>joy:=true</code> Run Electrode with foxglove and physical joystick<pre><code>ros2 launch electrode electrode.launch.py joy:=true\n</code></pre> </p>"},{"location":"electrode/about/#example-of-using-electrode-with-a-physical-joystick-for-b3rb","title":"Example of using electrode with a physical joystick for B3RB.","text":"<p>While most physical joysticks on the market can be made to work with ROS 2, this example highlights a Logitech F310.</p> Logitech F310 button layout. <p></p>"},{"location":"electrode/about/#selecting-a-mode","title":"Selecting a Mode","text":"<ul> <li> A : Manual Mode</li> <li> X : CMD_VEL Mode (nav2)</li> <li> B : Auto Mode (other cmd_vel)</li> <li> Y : Calibration Mode</li> </ul>"},{"location":"electrode/about/#arming","title":"Arming","text":"<ul> <li>START: arm</li> <li>BACK: disarm</li> </ul>"},{"location":"electrode/about/#manual-mode","title":"Manual Mode","text":"<ul> <li>Left stick Up/Down: Throttle</li> <li>Right stick Left/Right: Steering</li> </ul>"},{"location":"electrode/about/#front-lights","title":"Front Lights","text":"<ul> <li>LB: Front lights on</li> <li>RB: Front lights off</li> </ul>"},{"location":"electrode/about/#using-electrode-without-a-ros-2-workspace","title":"Using Electrode without a ROS 2 workspace","text":"<p>To use Electrode without ROS 2 on a system use foxglove-studio. </p> <ol> <li> <p>Download the latest foxglove-studio for your system (Linux/Windows) and install it.</p> If using with linux only use debian installer. <p>Do not use the snap version, only follow instructions for debian linux install.</p> </li> <li> <p>Download the latest foxglove-cognipilot-joy extension asset <code>cognipilot.cognipilot-joystick-&lt;version&gt;.zip</code>  for Airy.</p> </li> <li> <p>Unzip compressed folder and put it in correct path for operating systems foxglove-studio.   On Linux:     Move and extract extension on Linux:<pre><code>mkdir -p ~/.foxglove-studio/extensions\nmv &lt;path-to&gt;/cognipilot.cognipilot-joystick-*.zip ~/.foxglove-studio/extensions\ncd ~/.foxglove-studio/extensions\nunzip cognipilot.cognipilot-joystick-*.zip\n</code></pre>     On Windows:</p> <ol> <li>Go to <code>Users/&lt;User&gt;/</code> and see if there is a .foxglove-studio/extensions folder, enable seeing hidden folders if not already enabled. If the folder path exists proceed to step <code>d.</code>, if not continue with step <code>b.</code></li> <li> <p>Create a .foxglove-studio folder in <code>Users/&lt;User&gt;/</code>.</p> Creating a .foxglove-studio folder <code>Users/&lt;User&gt;/</code>. <p></p> </li> <li> <p>Create an extensions folder in <code>Users/&lt;User&gt;/.foxglove-studio</code>.</p> Creating an extensions folder in <code>Users/&lt;User&gt;/.foxglove-studio</code>. <p></p> </li> <li> <p>Go to location where <code>cognipilot.cognipilot-joystick-&lt;version&gt;.zip</code> was downloaded <code>right click the .zip</code> and select <code>Extract All...</code></p> Select <code>Extract All...</code> on <code>cognipilot.cognipilot-joystick-&lt;version&gt;.zip</code>. <p></p> </li> <li> <p>Provide extraction path to <code>Users/&lt;User&gt;/.foxglove-studio/extensions</code> and press extract.</p> Provide extraction path to <code>Users/&lt;User&gt;/.foxglove-studio/extensions</code>. <p></p> </li> </ol> </li> <li> <p>Download desired platform layout for foxglove by selecting the <code>&lt;robot&gt;.json</code> file on GitHub and pressing the download icon.</p> Example of downloading <code>b3rb.json</code> layout for foxglove. <p></p> </li> <li> <p>Open the foxglove-studio application.</p> </li> <li> <p>Connect foxglove-studio to the correct <code>foxglove_bridge</code> websocket's <code>ip address</code> and <code>port</code> in the format <code>ws://&lt;ip-address&gt;:&lt;port&gt;</code>.</p> Connecting foxglove-studio to the correct <code>foxglove_bridge</code> websocket's <code>ip address</code> and <code>port</code>. <p></p> </li> </ol>"},{"location":"getting_started/install/","title":"Installation for development computer","text":"Looking for instructions on how to also install on a NavQPlus? <p>Click here to get instructions on how to setup and configure a NavQPlus. Continue this guide for installing CogniPilot on a native development computer.</p>"},{"location":"getting_started/install/#requirements","title":"Requirements","text":"<ul> <li>Ubuntu 22.04 host environment.</li> <li>Stable internet connection for downloading and installing packages.</li> </ul> <p>This may work on other environments but only Ubuntu 22.04 is officially supported.</p>"},{"location":"getting_started/install/#optional-before-installing","title":"Optional before installing","text":""},{"location":"getting_started/install/#setup-ssh-keys-on-host-and-github","title":"Setup SSH keys on host and GitHub","text":"<p>If planning to develop and make changes to code it is suggested to set up ssh keys, however, it is not strictly required to do so.</p> <ul> <li>Ensure that ssh keys are setup on host computer and GitHub to be able to clone the CogniPilot repositories with ssh.</li> </ul>"},{"location":"getting_started/install/#setup-gpg-keys-on-host-and-github","title":"Setup GPG keys on host and GitHub","text":"<ul> <li>Optionally setup gpg keys on host computer and GitHub to sign commits.</li> </ul>"},{"location":"getting_started/install/#use-cognipilot-universal-installer","title":"Use CogniPilot universal installer","text":"Using Docker instead. <p>If preffering to use docker, there is a Docker Development Container that may be used instead.</p> <p>To install CogniPilot on a system download the universal installer and run it (follow the prompts in the installer).</p> Download and run the universal installer:<pre><code>sudo apt-get update\nsudo apt-get install git wget -y\nmkdir -p ~/cognipilot/installer\nwget -O ~/cognipilot/installer/install_cognipilot.sh https://raw.githubusercontent.com/CogniPilot/helmet/main/install/install_cognipilot.sh\nchmod a+x ~/cognipilot/installer/install_cognipilot.sh\n/bin/bash ~/cognipilot/installer/install_cognipilot.sh\n</code></pre> When prompted to choose a release: <ol> <li>airy for a stable non-development release.</li> <li>main for active development.</li> </ol> When prompted to choose installer type select 1 for native: <ol> <li>native select this for installing on development computer</li> <li>navqplus only if installing on a NavQPlus image that does not already have the installer on it. Click here for the proper way to install on a NavQPlus.</li> </ol> When prompted to choose whether or not to use ssh-keys: <ul> <li>y to clone with ssh keys, best for development work but only select if ssh keys are already present and setup with GitHub.</li> <li>n to clone with https, best for users who do not plan to make modifications or develop.</li> </ul>"},{"location":"getting_started/install/#build-the-workspace","title":"Build the workspace","text":"The <code>build_workspace</code> script: <ul> <li>Sets up the workspaces using vcs and yaml files provided in helmet.</li> <li>Builds Cranium ROS 2 workspace.</li> <li>Builds Cerebri (Zephyr RTOS native_sim) for software-in-the-loop simulation.</li> <li>Builds Cyecca (control/estimation software).</li> <li>Builds Electrode ROS 2 workspace (ground station software).</li> </ul> <p>Build the CogniPilot workspace with <code>build_workspace</code> script (follow the prompts in the workspace builder).</p> Run the build_workspace script:<pre><code>build_workspace\n</code></pre> When prompted to choose whether or not to use ssh-keys: <ul> <li>y to clone with ssh keys, best for development work but only select if ssh keys are already present and setup with GitHub.</li> <li>n to clone with https, best for users who do not plan to make modifications or develop.</li> </ul> When prompted to choose a platform to build: <ol> <li>b3rb is an ackermann based mobile robotic platform with simulation.</li> <li>elm4 is a differential drive based mobile robotic platform with simulation.</li> </ol>"},{"location":"getting_started/install/#platforms","title":"Platforms","text":"<p>Currently supported platforms in this release are B3RB and ELM4.</p>"},{"location":"getting_started/install/#using-a-real-platform","title":"Using a real platform:","text":"<ul> <li>B3RB hardware guide.</li> <li>ELM4 hardware guide coming soon.</li> </ul>"},{"location":"getting_started/install/#simulating-a-platform","title":"Simulating a platform:","text":"<ul> <li>B3RB simulation guide.</li> <li>ELM4 simulation guide coming soon.</li> </ul>"},{"location":"getting_started/install/#convenience-scripts","title":"Convenience Scripts","text":""},{"location":"getting_started/install/#docs-script","title":"docs script","text":"The <code>docs</code> script: <ul> <li>Downloads and builds the documentation repositories for the documentation currently being read so that contributions can be made easily.</li> <li>Allows for selection of documents to be served with mkdocs.</li> </ul> <p>To view the docs offline locally or to contribute to them use the <code>docs</code> convenience script (follow the prompts for the correct docs).</p> Run the docs convenience script:<pre><code>docs\n</code></pre> When prompted to choose whether or not to use ssh-keys: <ul> <li>y to clone with ssh keys, best if contributing to the documentation but only select if ssh keys are already present and setup with GitHub.</li> <li>n to clone with https, best for users who do not plan to contribute and only want a local viewer.</li> </ul> When prompted to choose a doc to build: <ol> <li>airy is the airy developers guide site (airy.cognipilot.org).</li> <li>overview is the release overview site (cognipilot.org).</li> </ol> I ran the command where are the docs? <p>Click here to access the locally built docs on 0.0.0.0:8000</p>"},{"location":"getting_started/install/#cyecca-script","title":"cyecca script","text":"The <code>cyecca</code> script: <ul> <li>Starts a JupyterLab instance for Cyecca to aid in developing control and estimation algorithms.</li> </ul> <p>To develop algorithms with <code>cyecca</code> use the <code>cyecca</code> convenience script.</p> Run the cyeccs convenience script:<pre><code>cyecca\n</code></pre>"},{"location":"getting_started/advanced/docker/","title":"Docker","text":"<p>If you wish, there is a development docker container (docker hub, docker source) for CogniPilot with Nvidia GPU support. If you use this option, do not run the native_install script, as the packages are already installed.</p>"},{"location":"getting_started/advanced/docker/#dependencies","title":"Dependencies","text":"<p>You must install the latest official docker.</p> <ul> <li>Install Docker</li> </ul> <p>Tip</p> <p>Don't forget Linux Post Install </p>"},{"location":"getting_started/advanced/docker/#clone-docker-repository","title":"Clone Docker Repository","text":"<p>On the Host <pre><code>mkdir -p ~/cognipilot\ncd ~/cognipilot\ngit clone https://github.com/cognipilot/docker\ncd  ~/cognipilot/docker\ngit submodule update --init --recursive\n</code></pre></p>"},{"location":"getting_started/advanced/docker/#start-the-docker-image","title":"Start the Docker Image","text":"<p>The dream start command, automatically pulls the dream image from dockerhub, and starts the image.</p> <p>On the Host <pre><code>cd ~/cognipilot/docker/dream\n./dream start\n</code></pre></p>"},{"location":"getting_started/advanced/docker/#execute-a-command-on-the-docker-image","title":"Execute a Command on the Docker Image","text":"<p>This starts a shell within the container.</p> <p>On the Host <pre><code>./dream exec\n</code></pre></p> <p>If passed extra arguments will run those commands as well.</p>"},{"location":"getting_started/advanced/docker/#convenience-scripts-docker-specific","title":"Convenience Scripts (Docker Specific)","text":""},{"location":"getting_started/advanced/docker/#unlock","title":"unlock","text":"<p>This command executes the script docs.</p> <ul> <li>Unlocks GPG and SSH keys mounted in the docker image.</li> </ul> <p>Within the Container <pre><code>unlock\n</code></pre></p> <p>See the other non-docker specific scripts in the main installation</p>"},{"location":"getting_started/advanced/docker/#build-the-docker-image-for-advanced-users","title":"Build the Docker Image (For Advanced Users)","text":"<p>This process will take awhile. It is usually sufficient to use dream start instead, which will automatically pull the latest image from dockerhub.</p> <p>On the Host <pre><code>cd ~/cognipilot/docker/dream\n./dream build\n</code></pre></p>"},{"location":"helmet/about/","title":"Helmet Overview","text":""},{"location":"reference_systems/b3rb/about/","title":"B3RB Platform Overview","text":"<p>The B3RB platform has both a simulation and real vehicle as a reference system for Ackermann based vehicles.</p> <p>To use the B3RB follow the setup and the guide on operating the platform.</p>"},{"location":"reference_systems/b3rb/electrode/","title":"B3RB Electrode Overview","text":"<p>Electrode can be run with foxglove-studio or RVIZ 2 backends for the real and simulated B3RB. Foxglove-studio is the reccomended and default backend for Electrode.</p> <p>Electrode uses a joystick (virtual or physical) to control the B3RB.</p> <p>To visualize and control the B3RB it is reccomended to understand the key concepts and backend options with Electrode.</p>"},{"location":"reference_systems/b3rb/electrode/#using-the-default-electrode-foxglove-studio-backend-with-b3rb","title":"Using the default Electrode foxglove-studio backend with B3RB.","text":"If using the foxglove backend for Electrode. <p>Make sure to have first followed instructions to install foxglove-studio and the foxglove CogniPilot Joystick extension.</p> <p>By default Electrode uses foxglove-studio, for foxglove-studio to connect to the B3RB or B3RB simulation <code>foxglove_bridge</code> must be running.</p> <p>On the robot's NavQPlus this happen automatically when running <code>ros2 launch b3rb_bringup robot.launch.py</code> and uses by default the current network address of the WiFi <code>mlan0</code> to instantiate the websockets over.</p> How do I make <code>foxglove_bridge</code> on the NavQPlus use a different network address? <p>A different network address can be used by passing it to the launch script. Use different network address for foxglove_bridge:<pre><code>ros2 launch b3rb_bringup robot.launch.py address:='&lt;other.ip.address&gt;'\n</code></pre> And then connect to it in Foxglove-Studio with <code>ws://&lt;other.ip.address&gt;:4242</code>.</p> What if I don't want to run <code>foxglove_bridge</code> on the NavQPlus? <p>Appending <code>foxglove:=false</code> to the launch command will prevent <code>foxglove_bridge</code> from running. Run without foxglove_bridge:<pre><code>ros2 launch b3rb_bringup robot.launch.py foxglove:=false\n</code></pre></p> My foxglove studio connected but it's not showing what I would expect it to, how do I load the <code>b3rb.json</code> layout file? <ol> <li>Click the foxglove logo drop down in upper left followed by <code>Import layout from file...</code> </li> <li>Click the <code>b3rb.json</code> file followed by clicking <code>Select</code> by navigating <code>Home &gt; cognipilot &gt; electrode &gt; src &gt; electrode &gt; foxglove_layouts &gt; b3rb.json</code> </li> <li>The layout should now be present regardless of foxglove being connected to a websocket data source. </li> </ol>"},{"location":"reference_systems/b3rb/electrode/#optionally-run-electrode-with-the-rviz-2-backend-for-b3rb","title":"Optionally run Electrode with the RVIZ 2 backend for B3RB.","text":"<p>Electrode can be optionally run with the RVIZ 2 backend, however, it requires a physical joystick device for input. Electrode with RVIZ 2:<pre><code>ros2 launch electrode electrode.launch.py rviz2:=true\n</code></pre></p> <p>Make sure to also run without the <code>foxglove_bridge</code> on the NavQPlus. Run without foxglove_bridge:<pre><code>ros2 launch b3rb_bringup robot.launch.py foxglove:=false\n</code></pre></p>"},{"location":"reference_systems/b3rb/hardware/","title":"B3RB Hardware Overview","text":"<p>Currently this section defers to the information on NXP's site.</p>"},{"location":"reference_systems/b3rb/operate/","title":"B3RB Operation Overview","text":"<p>To operate the B3RB platform:</p> <ol> <li>Follow the B3RB setup guide.</li> <li>Run Electrode for B3RB.</li> <li>Launch <code>b3rb_bringup</code> on B3RB's NavQPlus.</li> <li>Understand the lights and sounds of the B3RB for fast diagnosis.</li> <li>Navigate Using the electrode interface.</li> </ol>"},{"location":"reference_systems/b3rb/operate/#following-the-b3rb-setup-guide","title":"Following the B3RB setup guide","text":"<p>Make sure to have first followed the B3RB setup guide.</p>"},{"location":"reference_systems/b3rb/operate/#running-electrode-for-b3rb","title":"Running Electrode for B3RB","text":"<p>Choose and run the desired Electrode backend for B3RB.</p>"},{"location":"reference_systems/b3rb/operate/#launching-b3rb_bringup-on-the-navqplus","title":"Launching <code>b3rb_bringup</code> on the NavQPlus","text":"<p>Shell into the NavQPlus (typically over WiFi).</p> <p>Run the B3RB launch file.</p> Run B3RB launch file.<pre><code>ros2 launch b3rb_bringup robot.launch.py\n</code></pre>"},{"location":"reference_systems/b3rb/operate/#understanding-the-lights-and-sounds-of-the-b3rb-for-fast-diagnosis","title":"Understanding the lights and sounds of the B3RB for fast diagnosis","text":"<p>Using the lights and sounds on the B3RB is a useful way to determine the system's current status regardless of Electrode running.</p>"},{"location":"reference_systems/b3rb/operate/#navigating-using-the-electrode-interface","title":"Navigating Using the electrode interface","text":""},{"location":"reference_systems/b3rb/operate/#video-example-of-using-b3rb","title":"Video example of using B3RB","text":"Example of using B3RB with electrode running foxglove-studio."},{"location":"reference_systems/b3rb/setup/","title":"B3RB Setup","text":"<p>Overview of setup for the B3RB platform:</p> <ol> <li>Put together the physical B3RB platform.</li> <li>Setup a development machine for B3RB.</li> <li>Setup the NavQPlus on B3RB.</li> <li>Build and flash the Cerebri image for B3RB.</li> </ol>"},{"location":"reference_systems/b3rb/setup/#putting-together-the-physical-b3rb-platform","title":"Putting together the physical B3RB platform","text":"<p>Please follow the links in the hardware overview.</p>"},{"location":"reference_systems/b3rb/setup/#setup-a-development-machine-for-b3rb","title":"Setup a development machine for B3RB","text":"<p>Please follow the the getting started guide for development computers.</p>"},{"location":"reference_systems/b3rb/setup/#setup-the-navqplus-on-b3rb","title":"Setup the NavQPlus on B3RB","text":"<p>Please follow the the NavQPlus setup guide.</p>"},{"location":"reference_systems/b3rb/setup/#build-and-flash-the-cerebri-image-for-b3rb","title":"Build and flash the Cerebri image for B3RB","text":"<p>If choosing to use the stable Airy release, make sure Cerebri is on the airy branch.</p> How do I know what branch Cerebri is on? <p>Check cerebri branch.<pre><code>cd ~/cognipilot/ws/cerebri\ngit status\n</code></pre> Which should return: <pre><code>On branch airy\nYour branch is up to date with 'origin/airy'.\n\nnothing to commit, working tree clean\n</code></pre> If it does not show that perform a <code>git checkout</code>: Checkout airy branch on cerebri.<pre><code>git checkout airy\n</code></pre></p>"},{"location":"reference_systems/b3rb/setup/#check-for-updates-on-cerebri","title":"Check for updates on Cerebri","text":"Update Cerebri.<pre><code>cd ~/cognipilot/ws/cerebri\ngit pull\n</code></pre>"},{"location":"reference_systems/b3rb/setup/#make-sure-cerebris-zephyr-dependencies-are-up-to-date-with-west","title":"Make sure Cerebri's Zephyr dependencies are up to date with <code>west</code>","text":"Updating Cerebri's Zephyr dependencies with west.<pre><code>cd ~/cognipilot/ws/cerebri\nwest update\n</code></pre>"},{"location":"reference_systems/b3rb/setup/#build-cerebri-b3rb-image-for-mr-canhubk3-with-west","title":"Build Cerebri B3RB image for MR CANHUBK3 with <code>west</code>","text":"Building Cerebri B3RB image with west.<pre><code>cd ~/cognipilot/ws/cerebri\nwest build -b mr_canhubk3 app/b3rb -p\n</code></pre>"},{"location":"reference_systems/b3rb/setup/#flash-cerebri-b3rb-image-with-west-to-mr-canhubk3","title":"Flash Cerebri B3RB image with <code>west</code> to MR CANHUBK3","text":"<p>Make sure Segger JLink is on your system and the MR CANHUBK3 is connected to the JLink programmer.</p> Flashing MR CANHUBK3 with the Cerebri B3RB image using west.<pre><code>cd ~/cognipilot/ws/cerebri\nwest flash\n</code></pre>"},{"location":"reference_systems/b3rb/simulation/","title":"B3RB Simulation","text":"<p>Simulation uses gazebo garden to simulate sensors and physics in the \"dream\" worlds that connects to Cerebri running ontop Zephyr RTOS <code>native_sim</code>.</p>"},{"location":"reference_systems/b3rb/simulation/#before-running-simulation","title":"Before running simulation","text":"<p>Before running the simulation for the first time make sure to have first followed the installation for development computer guide. Once at building the workspace make sure to select <code>1. b3rb</code> for the platform. This will also build Cerebri for <code>native_sim</code> so the section below \"Build Cerebri for <code>native_sim</code>\" can be skipped if the <code>build_workspace</code> script was just run. If other images have been built in Cerebri since running the script make sure to follow \"Build Cerebri for <code>native_sim</code>\". </p>"},{"location":"reference_systems/b3rb/simulation/#build-cerebri-for-native_sim","title":"Build Cerebri for <code>native_sim</code>","text":"<p>To build Cerebri for native_sim (posix) make sure the Zephyr RTOS build environment is up to date and that at some point previously the <code>build_workspace</code> script was run for b3rb.</p> If the <code>build_workspace</code> script was just run, the steps in this section can be skipped. <p>This section only needs to be run if different images have been built in Cerebri since having run the <code>build_workspace</code> script.</p> Update Zephyr RTOS build environment with west:<pre><code>cd ~/cognipilot/ws/cerebri\ngit pull\nwest update\n</code></pre> <p>Build the Cerebri for <code>native_sim</code>, install and source it so it can be found. Build and install Cerebri for native_sim:<pre><code>west build -b native_sim app/b3rb/ -p -t install\nsource ~/.bashrc\n</code></pre></p>"},{"location":"reference_systems/b3rb/simulation/#run-electrode","title":"Run Electrode","text":"If using the foxglove backend for Electrode. <p>Make sure to have first followed instructions to install foxglove-studio and the foxglove CogniPilot Joystick extension.</p> <p>To visualize and control the simulated B3RB it is reccomended to understand the key concepts and backend options with Electrode, the default Electrode backend is foxglove-studio.</p>"},{"location":"reference_systems/b3rb/simulation/#run-electrode-with-the-foxglove-studio-backend-for-b3rb-simulation","title":"Run Electrode with the foxglove-studio backend for B3RB simulation.","text":"Electrode for simulation with foxglove:<pre><code>ros2 launch electrode electrode.launch.py sim:=true\n</code></pre> Foxglove studio opened, how do I connect it to the simulation? <p>After launching electrode with only passing <code>sim:=true</code> connect to it on <code>ws://localhost:8765</code> </p> Example of depot world simulation with electrode running foxglove. <p></p> My foxglove studio connected but it's not showing what I would expect it to, how do I load the <code>b3rb.json</code> layout file? <ol> <li>Click the foxglove logo drop down in upper left followed by <code>Import layout from file...</code> </li> <li>Click the <code>b3rb.json</code> file followed by clicking <code>Select</code> by navigating <code>Home &gt; cognipilot &gt; electrode &gt; src &gt; electrode &gt; foxglove_layouts &gt; b3rb.json</code> </li> <li>The layout should now be present regardless of foxglove being connected to a websocket data source. </li> </ol>"},{"location":"reference_systems/b3rb/simulation/#optionally-run-electrode-with-the-rviz-2-backend-for-b3rb-simulation","title":"Optionally run Electrode with the RVIZ 2 backend for B3RB simulation.","text":"<p>Electrode can be optionally run with the RVIZ 2 backend for simulation, however, it requires a physical joystick device for input. Electrode for simulation with RVIZ 2:<pre><code>ros2 launch electrode electrode.launch.py rviz2:=true sim:=true\n</code></pre></p> Example of depot world simulation with electrode running rviz2. <p></p>"},{"location":"reference_systems/b3rb/simulation/#run-b3rb-sil","title":"Run B3RB SIL","text":"<p>The default dream world for B3RB is the basic map world. Launch simulation with basic map world:<pre><code>ros2 launch b3rb_gz_bringup sil.launch.py\n</code></pre></p> My ROS 2 cerebri_bringup node is showing an error and is keeping simulation from running. <p>If the simulation launch script is throwing an error about cerebri_bringup make sure that cerebri is built, installed and sourced properly for <code>native_sim</code>.</p> <p>If running on a machine with a powerful graphics card optionally run the more gaphics intensive depot world.</p> Launch simulation with depot world:<pre><code>ros2 launch b3rb_gz_bringup sil.launch.py world:=depot\n</code></pre>"},{"location":"reference_systems/b3rb/simulation/#video-example-of-using-the-simulation","title":"Video example of using the simulation","text":"Example of using simulation with electrode running foxglove."},{"location":"reference_systems/b3rb/status/","title":"B3RB Status Lighting and Sounds","text":""},{"location":"reference_systems/b3rb/status/#status-lights","title":"Status Lights","text":"<p>The tailights on the B3RB are used for showing the current system status and breathe to show the system is alive.</p> My status lights are not breathing, what's wrong? <ul> <li>If the status lights are not breathing and there is a startup sound check your board for:<ul> <li>LED connection to SPI2 port on MR CANHUBK3.</li> <li>cerebri/app/b3rb/prj.conf setting for CONFIG_CEREBRI_B3RB_LIGHTING=y</li> <li>cerebri/app/b3rb/prj.conf setting for CONFIG_CEREBRI_ACTUATE_LED_ARRAY=y</li> <li>cerebri/app/b3rb/boards/mr_canhubk3.conf setting for CONFIG_LED_STRIP=y CONFIG_APA102_STRIP=y</li> </ul> </li> <li>If the status lights are not breathing and there is no startup sound it can be a sign there was a potential power event that occured and the PMIC triggered the FS26 watchdog. Steps to fix watchdog timeout:<ol> <li>Check all wiring is plugged in correctly.</li> <li>Power off the board.</li> <li>Remove the jumper JP1 (pins 1-2 open), which is connected by default.</li> <li>Power on the board.</li> <li>Reconnect the jumper JP1 (pins 1-2 shorted).</li> </ol> </li> </ul>"},{"location":"reference_systems/b3rb/status/#startup-lights","title":"Startup Lights","text":"[   ]  [   ] Startup breathing light pattern [Safety On, Disarm, Mode Unknown]."},{"location":"reference_systems/b3rb/status/#safety-lights","title":"Safety Lights","text":""},{"location":"reference_systems/b3rb/status/#safety-on-lights","title":"Safety On Lights","text":"[   ]  [   ] The outer set of lights are green when the Safety is On."},{"location":"reference_systems/b3rb/status/#safety-off-lights","title":"Safety Off Lights","text":"[   ]  [   ] The outer set of lights are red when the Safety is Off."},{"location":"reference_systems/b3rb/status/#arming-and-critical-fuel-lights","title":"Arming and Critical Fuel Lights","text":""},{"location":"reference_systems/b3rb/status/#disarmed-lights","title":"Disarmed Lights","text":"[   ]  [  ] The middle set of lights are green when Disarmed."},{"location":"reference_systems/b3rb/status/#armed-lights","title":"Armed Lights","text":"[   ]  [   ] The middle set of lights are red when Armed."},{"location":"reference_systems/b3rb/status/#fuel-critical-lights","title":"Fuel Critical Lights","text":"[   ]  [   ] The middle set of lights are yellow when Fuel is Critical."},{"location":"reference_systems/b3rb/status/#mode-lights","title":"Mode Lights","text":""},{"location":"reference_systems/b3rb/status/#mode-unknown-lights","title":"Mode Unknown Lights","text":"[   ]  [  ] The inner set of lights are white when Mode Unknown."},{"location":"reference_systems/b3rb/status/#mode-manual-lights","title":"Mode Manual Lights","text":"[   ]  [  ] The inner set of lights are green when Mode Manual."},{"location":"reference_systems/b3rb/status/#mode-cmd_vel-lights","title":"Mode CMD_VEL Lights","text":"[   ]  [  ] The inner set of lights are blue when Mode CMD_VEL."},{"location":"reference_systems/b3rb/status/#mode-calibration-lights","title":"Mode Calibration Lights","text":"[   ]  [  ] The inner set of lights are yellow when Mode Calibration."},{"location":"reference_systems/b3rb/status/#status-sounds","title":"Status Sounds","text":"<p>These sounds allow for audio based system diagnosis.</p>"},{"location":"reference_systems/b3rb/status/#startup-sound","title":"Startup Sound","text":""},{"location":"reference_systems/b3rb/status/#flight-of-the-alicanto","title":"Flight of the Alicanto","text":"Flight of the Alicanto startup sound signifies the system has booted. I plugged power in but didn't hear the sound, what's wrong? <ul> <li>If the status lights are breathing but there is no sound check your board setup for:<ul> <li>Proper ADAP board revision (Rev C).</li> <li>Buzzer connection to GPS port on ADAP.</li> <li>prj.conf setting for CONFIG_CEREBRI_ACTUATE_SOUND=y</li> </ul> </li> <li>If there is no startup sound when powered on and the status lights are not breathing there is a potential that a power event occured and the PMIC triggered the FS26 watchdog. Steps to fix watchdog timeout:<ol> <li>Check all wiring is plugged in correctly.</li> <li>Power off the board.</li> <li>Remove the jumper JP1 (pins 1-2 open), which is connected by default.</li> <li>Power on the board.</li> <li>Reconnect the jumper JP1 (pins 1-2 shorted).</li> </ol> </li> </ul>"},{"location":"reference_systems/b3rb/status/#state-change-request-sounds","title":"State Change Request Sounds","text":""},{"location":"reference_systems/b3rb/status/#rejected-state-change-request","title":"Rejected State Change Request","text":"Low tone followed by mid-high-low-mid-high sinusoid. I keep hearing this rejection sound, what is causing it? <ul> <li>The rejection sound comes from the Finite State Machine (FSM) rejecting a transition request by the request not passing the transition guards.</li> <li>More information about the request rejection can be seen in with: <ul> <li><code>ros2 topic echo /cerebri/out/status</code> </li> <li>Electrode below the fuel guage in the Foxglove layout. </li> </ul> </li> </ul>"},{"location":"reference_systems/b3rb/status/#mode-sounds","title":"Mode Sounds","text":""},{"location":"reference_systems/b3rb/status/#manual-sound","title":"Manual Sound","text":"Morse Code 1 for manual mode enum (. - - - -)"},{"location":"reference_systems/b3rb/status/#cmd_vel-sound","title":"CMD_VEL Sound","text":"Morse Code 3 for CMD_VEL mode enum (. . . - -)"},{"location":"reference_systems/b3rb/status/#calibration-sound","title":"Calibration Sound","text":"Morse Code 4 for calibration mode enum (. . . . -)"},{"location":"reference_systems/b3rb/status/#safety-sounds","title":"Safety Sounds","text":""},{"location":"reference_systems/b3rb/status/#safety-off-sound","title":"Safety Off Sound","text":"Morse Code S increasing long octives (- - -)"},{"location":"reference_systems/b3rb/status/#safety-on-sound","title":"Safety On Sound","text":"Morse Code S decreasing long octives (- - -)"},{"location":"reference_systems/b3rb/status/#arming-sounds","title":"Arming Sounds","text":""},{"location":"reference_systems/b3rb/status/#arm-sound","title":"Arm Sound","text":"Morse Code A mid-high tone (. -)"},{"location":"reference_systems/b3rb/status/#disarm-sound","title":"Disarm Sound","text":"Morse Code A mid-low tone (. -)"},{"location":"reference_systems/b3rb/status/#connection-loss-sounds","title":"Connection Loss Sounds","text":""},{"location":"reference_systems/b3rb/status/#joy-input-loss-sound","title":"Joy Input Loss Sound","text":"Morse Code E every 3 seconds ( . ) (sounds only after safety is off)."},{"location":"reference_systems/b3rb/status/#fuel-status-sounds","title":"Fuel Status Sounds","text":""},{"location":"reference_systems/b3rb/status/#fuel-low-sound","title":"Fuel Low Sound","text":"Morse Code EK every 10 seconds ( . - . - )"},{"location":"reference_systems/b3rb/status/#fuel-critical-sound","title":"Fuel Critical Sound","text":"Morse Code EK continuous ( . - . - )"},{"location":"tools/cyecca/about/","title":"About Cyecca","text":"<p>Cyecca is a control and estimation library.  The library leverages Casadi based equation graphs and can be thought of the control and estimation equivalent of TensorFlow. The equation graph is used for automatic differentiation, a numerically efficient method for computing jacobians. Casadi's core is written in C, with Python and Matlab wrappers. Cyecca leverages the Python library in Casadi. Casadi allows the user to create advanced geometric algorithms without advanced knowledge of embedded programming. This provides a route for rapid development.</p>"},{"location":"tools/cyecca/about/#b3rb-example","title":"B3RB Example","text":"<p>For a complete example of how Cyecca may be used, the B3RB will be used as an example.</p>"},{"location":"tools/cyecca/about/#generation-of-equations","title":"Generation of Equations","text":"<p>The proceeding leverages the Cyecca library to generate a simple rover estimator in 2D.</p> Derive Rover Estimator:<pre><code>def derive_rover2d_estimator():\n    # define symbols\n    x = ca.SX.sym(\"x\")  # x position in world frame of rear axle (north)\n    y = ca.SX.sym(\"y\")  # y position in world frame of rear axle (east)\n    theta = ca.SX.sym(\"theta\")  # angular heading in world frame (rotation about down)\n    u = ca.SX.sym(\"u\")  # forward velocity, along body x\n    omega = ca.SX.sym(\"omega\")  # angular velocity around z axis\n    dt = ca.SX.sym(\"dt\")  # time stemp\n\n    G = lie.SE2\n    X = G.elem(ca.vertcat(x, y, theta))\n    v = G.algebra.elem(ca.vertcat(u, 0, omega))\n\n    X1 = X + v\n    f_predict = ca.Function(\n        \"predict\", [X.param, omega, u], [X1.param], [\"x0\", \"omega\", \"u\"], [\"x1\"]\n    )\n\n    eqs = {\"predict\": f_predict}\n    return eqs\n</code></pre> <p>Here the relevant variables of interest are defined. Relevant variables of interest:<pre><code>    # define symbols\n    x = ca.SX.sym(\"x\")  # x position in world frame of rear axle (north)\n    y = ca.SX.sym(\"y\")  # y position in world frame of rear axle (east)\n    theta = ca.SX.sym(\"theta\")  # angular heading in world frame (rotation about down)\n    u = ca.SX.sym(\"u\")  # forward velocity, along body x\n    omega = ca.SX.sym(\"omega\")  # angular velocity around z axis\n    dt = ca.SX.sym(\"dt\")  # time stemp\n</code></pre></p> SE2 Lie Algebra element:<pre><code>    G = lie.SE2  # the SE2 Lie group which describes planar 2D motion\n    X = G.elem(ca.vertcat(x, y, theta)) @ \n    v = G.algebra.elem(ca.vertcat(u, 0, omega))\n</code></pre> <p>The SE2 Lie Algebra element, which describes the rotational and linear movement of the rover u represents the distance travelled along the arc created with an angular change of omega these may be thought of at linear and angular velocity multiplied by time.</p> <pre><code>    X1 = X + v\n</code></pre> <p>This represents the exact integration in SE(2), there are no numerical integration errors due to the geometric nature of the integration in the Lie Algebra, one may think of this as  the Lie Group equivalent of: \\(x_1 = x_0 + u*dt\\), where \\(x_0\\) is the initial state, \\(x_1\\) is the final state, \\(u\\) is the velocity, and \\(dt\\) is the change in time.</p> <pre><code>    f_predict = ca.Function(\n        \"predict\", [X.param, omega, u], [X1.param], [\"x0\", \"omega\", \"u\"], [\"x1\"]\n    )\n\n    eqs = {\"predict\": f_predict}\n    return eqs\n</code></pre> <p>Finally the casadi function routine is used to construct and return the prediction function.</p>"},{"location":"tools/cyecca/about/#code-generation-routines","title":"Code Generation Routines","text":"Generate code:<pre><code>def generate_code(eqs: dict, filename, dest_dir: str, **kwargs):\n    dest_dir = Path(dest_dir)\n    dest_dir.mkdir(exist_ok=True)\n    p = {\n        \"verbose\": True,\n        \"mex\": False,           #(1)\n        \"cpp\": False,           #(2)\n        \"main\": False,          #(3)\n        \"with_header\": True,    #(4)\n        \"with_mem\": False,      #(5)\n        \"with_export\": False,   #(6)\n        \"with_import\": False,\n        \"include_math\": True,   #(7)\n        \"avoid_stack\": True,    #(8)\n    }\n    for k, v in kwargs.items():\n        assert k in p.keys()\n        p[k] = v\n\n    gen = ca.CodeGenerator(filename, p)\n    for name, eq in eqs.items():\n        gen.add(eq)\n    gen.generate(str(dest_dir) + os.se\n</code></pre> <ol> <li>Without mex which is used for Matlab.</li> <li>Without cpp since Cerebri is focused on MISRA C.</li> <li>Without a main function, just use functions in a library.</li> <li>With a header for use in the libray.</li> <li>Without mem, as internal memory is not necessary for these routines.</li> <li>Without export, as there is no need for dll export.</li> <li>With math, as this leverages the math routines.</li> <li>With avoid_stack, so the data used for calculations is explicitly passed in and not allocated with the stack of the function.</li> </ol>"},{"location":"tools/cyecca/about/#generating-code","title":"Generating Code","text":"<pre><code>if __name__ == \"__main__\":\n    #rover_plan()\n    #plt.show()\n    #test_bezier()\n\n    print(\"generating casadi equations\")\n    # derivate casadi functions\n    eqs = {}\n    eqs.update(derive_bezier6())\n    eqs.update(derive_rover())\n    eqs.update(derive_se2())\n    eqs.update(derive_rover2d_estimator())\n\n    for name, eq in eqs.items():\n        print('eq: ', name)\n\n    generate_code(eqs, filename=\"b3rb.c\", dest_dir=\"gen\")\n    print(\"complete\")\n</code></pre> <p>This routine generates from each of the relevant equation and creates the b3rb.c file.</p> <p>It is recommended to use poetry to run Cyecca, a working Poetry environment is provided with Cyecca. It is recommended to use this environment to generate the code.</p> <pre><code>poetry run -C ~/cognipilot/tools/src/cyecca python3 b3rb.py\n</code></pre>"},{"location":"tools/cyecca/about/#adding-casadi-generated-code-to-apps","title":"Adding Casadi Generated Code to Apps","text":"<p>Next add the generated source files to CMake.</p> <pre><code>if (CONFIG_CEREBRI_B3RB_CASADI)\n  list(APPEND SOURCE_FILES\n    src/casadi/gen/b3rb.c)\nendif()\n</code></pre>"},{"location":"tools/cyecca/about/#calling-casadi-based-function-from-cerebri","title":"Calling Casadi based function from Cerebri","text":"<p>It is now straight forward to call the generated Casadi function from within Cerebri.</p> <p>The estimator app collects the necessary information by subscribing to the following topics:</p> <ul> <li><code>imu</code> topic provides the required angular velocity data.</li> <li><code>wheel_odometry</code> topic provides the required distance travelled.</li> </ul> <p>The estimator app publishes:</p> <ul> <li><code>estimator_odometry</code> topic contains the location the robot believes it is at.</li> </ul> The Casadi function call:<pre><code>/* predict:(x0[3],omega,u)-&gt;(x1[3]) */\n{\n    double delta_theta = omega * dt;    //(1)\n    double x1[3];\n\n    // LOG_DBG(\"predict\");\n    CASADI_FUNC_ARGS(predict);\n    args[0] = ctx-&gt;x;                   //(2)\n    args[1] = &amp;delta_theta;             //(3)\n    args[2] = &amp;u;                       //(4)\n    res[0] = x1;                        //(5)\n    CASADI_FUNC_CALL(predict);          //(6)\n\n    // update x, W\n    handle_update(ctx, x1);\n}\n</code></pre> <ol> <li>Given the angular velocity \\(\\omega\\) from the z axis of the gyroscope, multiply the delta time \\(dt\\) since the last estimator run, and then compute the angular change \\(d\\theta\\) in radians. </li> <li>Load the function argument for initial state \\(x_0\\) into the Casadi function.</li> <li>Load the function argument for angular velocity \\(\\omega\\) into the Casadi function.</li> <li>Load the function argument for velocity \\(u\\) into the Casadi function.</li> <li>Set the result \\(x_1\\) in the res double array.</li> <li>The macro CASADI_FUNC_ARGS allocates the args, res, w (work), iw (integer work) vectors which are used in the function call.</li> </ol> <p>Here the signature is provided in the generated code</p> <p>The macros are defined here.</p> <pre><code>#define CASADI\\_FUNC\\_ARGS(name)              \\\n    casadi_int iw[name##_SZ_IW];            \\\n    casadi_real w[name##_SZ_W];             \\\n    const casadi_real* args[name##_SZ_ARG]; \\\n    casadi_real* res[name##_SZ_RES];        \\\n    int mem = 0;\n\n#define CASADI\\_FUNC\\_CALL(name) \\\n    name(args, res, iw, w, mem);\n</code></pre> <p>An Ipython notebook of this example can be found here</p>"}]}